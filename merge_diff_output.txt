
================================================================================
File: tools/code/common/Api.cs
Status: modified (+13 -2)
================================================================================

Changes in this PR:
```diff
@@ -639,9 +639,20 @@ private static async ValueTask PutNonSoapApi(ApiUri uri, ApiDto dto, HttpPipelin
         };
         await pipeline.PutContent(uri.ToUri(), BinaryData.FromObjectAsJson(modelWithoutSpecification), cancellationToken);
 
-        // Put API again with specification and import=true to ensure operations are imported from the specification
+        // Put API again with specification and import=true to ensure operations are imported from the specification.
+        // Only force ServiceUrl = null when the original value is null to prevent APIM from defaulting to base URL (issue #313).
+        // Otherwise, preserve the user's explicit serviceUrl value.
+        var modelForImport = dto.Properties == null || dto.Properties.ServiceUrl == null
+            ? dto with
+            {
+                Properties = dto.Properties == null
+                    ? new ApiDto.ApiCreateOrUpdateProperties { ServiceUrl = null }
+                    : dto.Properties with { ServiceUrl = null }
+            }
+            : dto;
+
         var uriWithImport = uri.ToUri().SetQueryParam("import", "true").ToUri();
-        await pipeline.PutContent(uriWithImport, BinaryData.FromObjectAsJson(dto), cancellationToken);
+        await pipeline.PutContent(uriWithImport, BinaryData.FromObjectAsJson(modelForImport), cancellationToken);
     }
 
     private static bool CreationInProgress(Response response)
```

Base branch (main) version (first 150 of 766 lines):
```
﻿using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Flurl;
using LanguageExt;
using Polly;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using YamlDotNet.System.Text.Json;

namespace common;

public sealed record ApiRevisionNumber
{
    private uint Value { get; }

    private ApiRevisionNumber(uint value)
    {
        ArgumentOutOfRangeException.ThrowIfNegativeOrZero(value, nameof(value));
        Value = value;
    }

    public int ToInt() => (int)Value;

    public override string ToString() => string.Create(CultureInfo.InvariantCulture, $"{Value}");

    public static ApiRevisionNumber From(int value) => new((uint)value);

    public static Option<ApiRevisionNumber> TryFrom(string? value) =>
        uint.TryParse(value, out var revisionNumber) && revisionNumber > 0
        ? new ApiRevisionNumber(revisionNumber)
        : Option<ApiRevisionNumber>.None;
}

public sealed record ApiName : ResourceName, IResourceName<ApiName>
{
    private const string RevisionSeparator = ";rev=";

    private ApiName(string value) : base(value) { }

    public static ApiName From(string value) => new(value);

    private static Either<string, (ApiName RootName, ApiRevisionNumber RevisionNumber)> TryParseRevisionedName(string name) =>
        name.Split(RevisionSeparator) switch
        {
        [var rootName, var revisionNumberString] =>
            ApiRevisionNumber.TryFrom(revisionNumberString)
                             .Map(revisionNumber => (ApiName.From(rootName), revisionNumber))
                             .ToEither($"'{revisionNumberString}' is not a valid revision number."),
            _ => $"Cannot parse name '{name}' as a revisioned API name."
        };

    public static Either<string, (ApiName RootName, ApiRevisionNumber RevisionNumber)> TryParseRevisionedName(ApiName name) =>
        TryParseRevisionedName(name.Value);

    public static bool IsNotRevisioned(ApiName name) => TryParseRevisionedName(name).IsLeft;

    public static bool IsRevisioned(ApiName name) => TryParseRevisionedName(name).IsRight;

    public static ApiName GetRootName(ApiName name) =>
        TryParseRevisionedName(name).Map(revisionedName => revisionedName.RootName).IfLeft(name);

    public static ApiName GetRevisionedName(ApiName name, ApiRevisionNumber revisionNumber)
    {
        var rootName = GetRootName(name);
        return ApiName.From($"{rootName.Value}{RevisionSeparator}{revisionNumber.ToInt()}");
    }
}

public sealed record ApisUri : ResourceUri
{
    public required ManagementServiceUri ServiceUri { get; init; }

    private static string PathSegment { get; } = "apis";

    protected override Uri Value => ServiceUri.ToUri().AppendPathSegment(PathSegment).ToUri();

    public static ApisUri From(ManagementServiceUri serviceUri) =>
        new() { ServiceUri = serviceUri };
}

public sealed record ApiUri : ResourceUri
{
    public required ApisUri Parent { get; init; }
    public required ApiName Name { get; init; }

    protected override Uri Value => Parent.ToUri().AppendPathSegment(Name.ToString()).ToUri();

    public static ApiUri From(ApiName name, ManagementServiceUri serviceUri) =>
        new()
        {
            Parent = ApisUri.From(serviceUri),
            Name = name
        };
}

public sealed record ApisDirectory : ResourceDirectory
{
    public required ManagementServiceDirectory ServiceDirectory { get; init; }

    private static string Name { get; } = "apis";

    protected override DirectoryInfo Value =>
        ServiceDirectory.ToDirectoryInfo().GetChildDirectory(Name);

    public static ApisDirectory From(ManagementServiceDirectory serviceDirectory) =>
        new() { ServiceDirectory = serviceDirectory };

    public static Option<ApisDirectory> TryParse(DirectoryInfo? directory, ManagementServiceDirectory serviceDirectory) =>
        directory is not null &&
        directory.Name == Name &&
        directory.Parent?.FullName == serviceDirectory.ToDirectoryInfo().FullName
            ? new ApisDirectory { ServiceDirectory = serviceDirectory }
            : Option<ApisDirectory>.None;
}

public sealed record ApiDirectory : ResourceDirectory
{
    public required ApisDirectory Parent { get; init; }

    public required ApiName Name { get; init; }

    protected override DirectoryInfo Value =>
        Parent.ToDirectoryInfo().GetChildDirectory(Name.ToString());

    public static ApiDirectory From(ApiName name, ManagementServiceDirectory serviceDirectory) =>
        new()
        {
            Parent = ApisDirectory.From(serviceDirectory),
            Name = name
        };

    public static Option<ApiDirectory> TryParse(DirectoryInfo? directory, ManagementServiceDirectory serviceDirectory) =>
        from parent in ApisDirectory.TryParse(directory?.Parent, serviceDirectory)
        select new ApiDirectory
        {
            Parent = parent,
            Name = ApiName.From(directory!.Name)
        };
... (616 more lines)
```


================================================================================
File: tools/code/common/WorkspaceApi.cs
Status: modified (+13 -2)
================================================================================

Changes in this PR:
```diff
@@ -586,9 +586,20 @@ private static async ValueTask PutNonSoapApi(WorkspaceApiUri uri, WorkspaceApiDt
         };
         await pipeline.PutContent(uri.ToUri(), BinaryData.FromObjectAsJson(modelWithoutSpecification), cancellationToken);
 
-        // Put API again with specification and import=true to ensure operations are imported from the specification
+        // Put API again with specification and import=true to ensure operations are imported from the specification.
+        // Only force ServiceUrl = null when the original value is null to prevent APIM from defaulting to base URL (issue #313).
+        // Otherwise, preserve the user's explicit serviceUrl value.
+        var modelForImport = dto.Properties == null || dto.Properties.ServiceUrl == null
+            ? dto with
+            {
+                Properties = dto.Properties == null
+                    ? new WorkspaceApiDto.ApiCreateOrUpdateProperties { ServiceUrl = null }
+                    : dto.Properties with { ServiceUrl = null }
+            }
+            : dto;
+
         var uriWithImport = uri.ToUri().SetQueryParam("import", "true").ToUri();
-        await pipeline.PutContent(uriWithImport, BinaryData.FromObjectAsJson(dto), cancellationToken);
+        await pipeline.PutContent(uriWithImport, BinaryData.FromObjectAsJson(modelForImport), cancellationToken);
     }
 
     private static bool CreationInProgress(Response response)
```

Base branch (main) version (first 150 of 704 lines):
```
﻿using Azure;
using Azure.Core;
using Azure.Core.Pipeline;
using Flurl;
using LanguageExt;
using Polly;
using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Text.Json;
using System.Text.Json.Nodes;
using System.Text.Json.Serialization;
using System.Threading;
using System.Threading.Tasks;
using YamlDotNet.System.Text.Json;

namespace common;

public sealed record WorkspaceApiName : ResourceName, IResourceName<WorkspaceApiName>
{
    private WorkspaceApiName(string value) : base(value) { }

    public static WorkspaceApiName From(string value) => new(value);

    public ApiName ToApiName() => ApiName.From(Value);
}

public sealed record WorkspaceApisUri : ResourceUri
{
    public required WorkspaceUri Parent { get; init; }

    private static string PathSegment { get; } = "apis";

    protected override Uri Value =>
        Parent.ToUri().AppendPathSegment(PathSegment).ToUri();

    public static WorkspaceApisUri From(WorkspaceName workspaceName, ManagementServiceUri serviceUri) =>
        new() { Parent = WorkspaceUri.From(workspaceName, serviceUri) };
}

public sealed record WorkspaceApiUri : ResourceUri
{
    public required WorkspaceApisUri Parent { get; init; }

    public required ApiName Name { get; init; }

    protected override Uri Value =>
        Parent.ToUri().AppendPathSegment(Name.ToString()).ToUri();

    public static WorkspaceApiUri From(ApiName name, WorkspaceName workspaceName, ManagementServiceUri serviceUri) =>
        new()
        {
            Parent = WorkspaceApisUri.From(workspaceName, serviceUri),
            Name = name
        };
}

public sealed record WorkspaceApisDirectory : ResourceDirectory
{
    public required WorkspaceDirectory Parent { get; init; }

    private static string Name { get; } = "apis";

    protected override DirectoryInfo Value =>
        Parent.ToDirectoryInfo().GetChildDirectory(Name);

    public static WorkspaceApisDirectory From(WorkspaceName workspaceName, ManagementServiceDirectory serviceDirectory) =>
        new() { Parent = WorkspaceDirectory.From(workspaceName, serviceDirectory) };

    public static Option<WorkspaceApisDirectory> TryParse(DirectoryInfo? directory, ManagementServiceDirectory serviceDirectory) =>
        directory is not null
        && directory.Name == Name
            ? from parent in WorkspaceDirectory.TryParse(directory.Parent, serviceDirectory)
              select new WorkspaceApisDirectory { Parent = parent }
            : Option<WorkspaceApisDirectory>.None;
}

public sealed record WorkspaceApiDirectory : ResourceDirectory
{
    public required WorkspaceApisDirectory Parent { get; init; }

    public required ApiName Name { get; init; }

    protected override DirectoryInfo Value =>
        Parent.ToDirectoryInfo().GetChildDirectory(Name.Value);

    public static WorkspaceApiDirectory From(ApiName name, WorkspaceName workspaceName, ManagementServiceDirectory serviceDirectory) =>
        new()
        {
            Parent = WorkspaceApisDirectory.From(workspaceName, serviceDirectory),
            Name = name
        };

    public static Option<WorkspaceApiDirectory> TryParse(DirectoryInfo? directory, ManagementServiceDirectory serviceDirectory) =>
        directory is not null
            ? from parent in WorkspaceApisDirectory.TryParse(directory?.Parent, serviceDirectory)
              let name = ApiName.From(directory!.Name)
              select new WorkspaceApiDirectory
              {
                  Parent = parent,
                  Name = name
              }
            : Option<WorkspaceApiDirectory>.None;
}

public sealed record WorkspaceApiInformationFile : ResourceFile
{
    public required WorkspaceApiDirectory Parent { get; init; }

    public static string Name { get; } = "apiInformation.json";

    protected override FileInfo Value =>
        Parent.ToDirectoryInfo().GetChildFile(Name);

    public static WorkspaceApiInformationFile From(ApiName name, WorkspaceName workspaceName, ManagementServiceDirectory serviceDirectory) =>
        new()
        {
            Parent = WorkspaceApiDirectory.From(name, workspaceName, serviceDirectory)
        };

    public static Option<WorkspaceApiInformationFile> TryParse(FileInfo? file, ManagementServiceDirectory serviceDirectory) =>
        file is not null &&
        file.Name == Name
            ? from parent in WorkspaceApiDirectory.TryParse(file.Directory, serviceDirectory)
              select new WorkspaceApiInformationFile
              {
                  Parent = parent
              }
            : Option<WorkspaceApiInformationFile>.None;
}

public sealed record WorkspaceApiDto
{
    [JsonPropertyName("properties")]
    [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
    public required ApiCreateOrUpdateProperties Properties { get; init; }

    public record ApiCreateOrUpdateProperties
    {
        [JsonPropertyName("path")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
        public string? Path { get; init; }

        [JsonPropertyName("apiRevision")]
        [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingDefault)]
        public string? ApiRevision { get; init; }
... (554 more lines)
```
